# -*- coding: utf-8 -*-
"""Web Traffic Prediction-a.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1A8PdaxB2p9-qXjDNGypbhZyuTn-sRc9a
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

train = pd.read_csv(r"C:\Users\Admin\Desktop\4 Web traffic prediction\train_1.csv")

train.head()

# original dataset shape
train.shape

# missing datta
empty_sample = train[train.isnull().any(axis=1)]
empty_sample.shape

# After dropping missing data, we still have 117277 samples.
df_cleaned=train.dropna()
df_cleaned.shape

# splitting the Page name
import re

def breakdown_topic(str):
    m = re.search('(.*)\_(.*).wikipedia.org\_(.*)\_(.*)', str)
    if m is not None:
        return m.group(1), m.group(2), m.group(3), m.group(4)
    else:
        return "", "", "", ""

print(breakdown_topic("王嘉爾_zh.wikipedia.org_all-access_spider"))
print(breakdown_topic("金俊秀_zh.wikipedia.org_all-access_spider"))
print(breakdown_topic("Jean-Claude_Van_Damme_fr.wikipedia.org_desktop_all-agents"))

page_details = df_cleaned.Page.str.extract(r'(?P<topic>.*)\_(?P<lang>.*).wikipedia.org\_(?P<access>.*)\_(?P<type>.*)')
page_details[0:10]

# The distribution of Language, Access and Type.
fig, axs  = plt.subplots(3,1,figsize=(12,12))

page_details["lang"].value_counts().sort_index().plot.bar(ax=axs[0])
axs[0].set_title('Language - distribution')

page_details["access"].value_counts().sort_index().plot.bar(ax=axs[1])
axs[1].set_title('Access - distribution')

page_details["type"].value_counts().sort_index().plot.bar(ax=axs[2])
axs[2].set_title('Type - distribution')

plt.tight_layout()

result = pd.concat([page_details, df_cleaned], axis=1, sort=False)
result.head()

# obvious difference in language
groupby=result.groupby('lang').median()
groupby.T.plot()

# usage data by each week.
groupby.iloc[:,0:100].T.plot()

model=df_cleaned
p=20
row = model.iloc[p,1:].values
X = row[0:549]
y = row[1:550]

# Splitting the dataset into the Training set and Test set
from sklearn.model_selection import train_test_split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.22, random_state = 0)


# Feature Scaling
from sklearn.preprocessing import MinMaxScaler
sc = MinMaxScaler()
X_train = np.reshape(X_train,(-1,1))
y_train = np.reshape(y_train,(-1,1))
X_train = sc.fit_transform(X_train)
y_train = sc.fit_transform(y_train)

#Training LSTM

#Reshaping Array
X_train = np.reshape(X_train, (X_train.shape[0],1,1))

# Importing the Keras libraries and packages for LSTM
from tensorflow.keras.models import Sequential
from tensorflow.keras import layers
from tensorflow.keras.layers import Dense, LSTM,RNN
from tensorflow.keras.optimizers import RMSprop

gru = Sequential()
gru.add(layers.SimpleRNN(128,activation = 'relu',return_sequences=True,input_shape=(None,1)))
gru.add(layers.Dense(1))
gru.compile(optimizer=RMSprop(), loss='mae')


# Fitting the RNN to the Training set

history = gru.fit(X_train, y_train,
                    epochs=30,
                    batch_size=300,
                    validation_split=0.2)

y_test.shape

# Getting the predicted Web View
inputs = X_test
inputs = np.reshape(inputs,(-1,1))
inputs = sc.transform(inputs)
inputs = np.reshape(inputs, (inputs.shape[0],1,1))
y_pred = gru.predict(inputs)
y_pred=np.reshape(y_pred, (inputs.shape[0],1))
y_pred = sc.inverse_transform(y_pred)

#Visualising Result
plt.figure
plt.plot(y_test, color = 'red', label = 'Real Web View')
plt.plot(y_pred, color = 'blue', label = 'Predicted Web View')
plt.title('Web View Forecasting - ' + model.iloc[p,0])
plt.xlabel('Number of Days from Start')
plt.ylabel('Web View')
plt.legend()
plt.show()

mse = ((y_pred - y_test) ** 2).mean()
print('The Mean Squared Error of our forecasts is {}'.format(round(mse, 2)))
print('The Root Mean Squared Error of our forecasts is {}'.format(round(np.sqrt(mse), 2)))

gru = Sequential()
gru.add(layers.SimpleRNN(128,activation = 'relu',return_sequences=True,input_shape=(None,1)))#
gru.add(layers.SimpleRNN(64, activation='relu',return_sequences=True))
gru.add(layers.Dense(100,activation='relu'))
gru.add(layers.SimpleRNN(32, activation='relu'))
gru.add(layers.Dense(10,activation='relu'))
gru.add(layers.Dense(1))
gru.compile(optimizer='adam', loss='mae')

# Fitting the RNN to the Training set

history = gru.fit(X_train, y_train,
                    epochs=30,
                    batch_size=300,
                    validation_split=0.2)

# Getting the predicted Web View
inputs = X_test
inputs = np.reshape(inputs,(-1,1))
inputs = sc.transform(inputs)
inputs = np.reshape(inputs, (inputs.shape[0],1,1))
y_pred = gru.predict(inputs)
y_pred=np.reshape(y_pred, (inputs.shape[0],1))
y_pred = sc.inverse_transform(y_pred)

#Visualising Result
plt.figure
plt.plot(y_test, color = 'red', label = 'Real Web View')
plt.plot(y_pred, color = 'blue', label = 'Predicted Web View')
plt.title('Web View Forecasting'+model.iloc[p,0])
plt.xlabel('Number of Days from Start')
plt.ylabel('Web View')
plt.legend()
plt.show()

mse = ((y_pred - y_test) ** 2).mean()
print('The Mean Squared Error of our forecasts is {}'.format(round(mse, 2)))
print('The Root Mean Squared Error of our forecasts is {}'.format(round(np.sqrt(mse), 2)))

"""LSTM"""

from tensorflow.keras import optimizers
# Initialising the lstm
regressor = Sequential()

# Adding the input layerand the LSTM layer

regressor.add(LSTM(units = 256, activation = 'relu', input_shape = (None, 1)))
regressor.add(Dense(units = 1))
regressor.compile(optimizer = optimizers.RMSprop(lr=0.01), loss = 'mse')

history = regressor.fit(X_train, y_train,
                    epochs=100,
                    batch_size=300,
                    validation_split=0.2)

# Getting the predicted Web View
inputs = X_test
inputs = np.reshape(inputs,(-1,1))
inputs = sc.transform(inputs)
inputs = np.reshape(inputs, (inputs.shape[0], 1, 1))
y_pred = regressor.predict(inputs)
y_pred = sc.inverse_transform(y_pred)
#rcParams['figure.figsize'] = 18, 8

#Visualising Result
plt.figure
plt.plot(y_test, color = 'red', label = 'Real Web View')
plt.plot(y_pred, color = 'blue', label = 'Predicted Web View')
plt.title('Web View Forecasting - '+model.iloc[p,0])
plt.xlabel('Number of Days from Start')
plt.ylabel('Web View')
plt.legend()
plt.show()

mse = ((y_pred - y_test) ** 2).mean()
print('The Mean Squared Error of our forecasts is {}'.format(round(mse, 2)))
print('The Root Mean Squared Error of our forecasts is {}'.format(round(np.sqrt(mse), 2)))

from tensorflow.keras import optimizers
# Initialising the lstm
regressor = Sequential()

# Adding the input layerand the LSTM layer
regressor.add(LSTM(units = 128, activation = 'linear', return_sequences=True,input_shape = (None, 1)))
regressor.add(LSTM(units = 64, activation = 'linear'))
regressor.add(Dense(units = 1))

# Compiling the RNN
regressor.compile(optimizer = 'adam', loss = 'mse')

# Fitting the RNN to the Training set
regressor.fit(X_train, y_train,
                    epochs=25,
                    batch_size=300,
                    validation_split=0.2)

# Getting the predicted Web View
inputs = X_test
inputs = np.reshape(inputs,(-1,1))
inputs = sc.transform(inputs)
inputs = np.reshape(inputs, (inputs.shape[0], 1, 1))
y_pred = regressor.predict(inputs)
y_pred = sc.inverse_transform(y_pred)
#rcParams['figure.figsize'] = 18, 8

#Visualising Result
plt.figure
plt.plot(y_test, color = 'red', label = 'Real Web View')
plt.plot(y_pred, color = 'blue', label = 'Predicted Web View')
plt.title('Web View Forecasting - '+model.iloc[p,0])
plt.xlabel('Number of Days from Start')
plt.ylabel('Web View')
plt.legend()
plt.show()

mse = ((y_pred - y_test) ** 2).mean()
print('The Mean Squared Error of our forecasts is {}'.format(round(mse, 2)))
print('The Root Mean Squared Error of our forecasts is {}'.format(round(np.sqrt(mse), 2)))



sklearn.linear_model.LinearRegression



model=df_cleaned
import random
for i in range(0,10):
    j = random.randint(0,100)
    
    row = model.iloc[j,1:].values
    X = row[0:549]
    y = row[1:550]
  
    # Splitting the dataset into the Training set and Test set
    from sklearn.model_selection import train_test_split
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.22, random_state = 0)

    # Feature Scaling
    from sklearn.preprocessing import MinMaxScaler
    sc = MinMaxScaler()
    X_train = np.reshape(X_train,(-1,1))
    y_train = np.reshape(y_train,(-1,1))
    X_train = sc.fit_transform(X_train)
    y_train = sc.fit_transform(y_train)

    #Training LSTM

    #Reshaping Array
    X_train = np.reshape(X_train, (X_train.shape[0],1,1))

    # Importing the Keras libraries and packages for LSTM
    from tensorflow.keras.models import Sequential
    from tensorflow.keras import layers
    from tensorflow.keras.layers import Dense, LSTM,RNN
    from tensorflow.keras.optimizers import RMSprop

    from tensorflow.keras import optimizers
    # Initialising the lstm
    regressor = Sequential()

    # Adding the input layerand the LSTM layer
    regressor.add(LSTM(units = 128, activation = 'linear', return_sequences=True,input_shape = (None, 1)))
    regressor.add(LSTM(units = 64, activation = 'linear'))
    regressor.add(Dense(units = 1))

    # Compiling the RNN
    regressor.compile(optimizer = 'adam', loss = 'mse')

    # Fitting the RNN to the Training set
    regressor.fit(X_train, y_train,
                        epochs=25,
                        batch_size=300,
                        validation_split=0.2)
   
    # Getting the predicted Web View
    inputs = X_test
    inputs = np.reshape(inputs,(-1,1))
    inputs = sc.transform(inputs)
    inputs = np.reshape(inputs, (inputs.shape[0], 1, 1))
    y_pred = regressor.predict(inputs)
    y_pred = sc.inverse_transform(y_pred)
    
    #Visualising Result
    plt.figure
    plt.plot(y_test, color = 'red', label = 'Real Web View')
    plt.plot(y_pred, color = 'blue', label = 'Predicted Web View')
    plt.title('Web View Forecasting'+model.iloc[j,0])
    plt.xlabel('Number of Days from Start')
    plt.ylabel('Web View')
    plt.legend()
    plt.show()
    mse = ((y_pred - y_test) ** 2).mean()
    print('The Mean Squared Error of our forecasts is {}'.format(round(mse, 2)))
    print('The Root Mean Squared Error of our forecasts is {}'.format(round(np.sqrt(mse), 2)))